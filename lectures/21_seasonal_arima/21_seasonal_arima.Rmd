---
title: "ISA 444: Business Forecasting"
subtitle: '21: Seasonal ARIMA Models'
author: '<br>Fadel M. Megahed, PhD <br><br> Endres Associate Professor <br> Farmer School of Business<br> Miami University<br><br> [`r icons::icon_style(icons::fontawesome("twitter"), fill = "white")` @FadelMegahed](https://twitter.com/FadelMegahed) <br> [`r icons::icon_style(icons::fontawesome("github"), fill = "white")` fmegahed](https://github.com/fmegahed/) <br> [`r icons::icon_style(icons::fontawesome("paper-plane", style = "solid"), fill = "white")` fmegahed@miamioh.edu](mailto:fmegahed@miamioh.edu)<br> [`r icons::icon_style(icons::fontawesome("question"), fill = "white")` Automated Scheduler for Office Hours](https://calendly.com/fmegahed)<br><br>'
date: "Spring 2023"
output:
  xaringan::moon_reader:
    self_contained: true
    css: [default, "../../style_files/fonts.css", "../../style_files/my-theme.css"]
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      highlightLanguage: ["r"]
      countIncrementalSlides: false
      ratio: "16:9"
header-includes:  
  - "../../style_files/header.html"
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(cache = TRUE,
                      echo = TRUE,
                      warning = FALSE,
                      message = FALSE,
                      progress = FALSE, 
                      verbose = FALSE,
                      dev = 'png',
                      dpi = 300,
                      fig.asp = 0.618,
                      fig.align = 'center',
                      out.width = '70%')

options(htmltools.dir.version = FALSE)


miamired = '#C3142D'

if(require(pacman)==FALSE) install.packages("pacman")
if(require(devtools)==FALSE) install.packages("devtools")
if(require(countdown)==FALSE) devtools::install_github("gadenbuie/countdown")
if(require(xaringanExtra)==FALSE) devtools::install_github("gadenbuie/xaringanExtra")
if(require(emo)==FALSE) devtools::install_github("hadley/emo")
if(require(icons)==FALSE) devtools::install_github("mitchelloharawild/icons")

pacman::p_load(gifski, av, gganimate, ggtext, glue, extrafont, # for animations
               emojifont, emo, RefManageR, xaringanExtra, countdown, downlit) # for slides
```

```{r xaringan-themer, include=FALSE, warning=FALSE}
if(require(xaringanthemer) == FALSE) install.packages("xaringanthemer")
library(xaringanthemer)

style_mono_accent(base_color = "#84d6d3",
                  base_font_size = "20px")

xaringanExtra::use_extra_styles(
  hover_code_line = TRUE,         
  mute_unhighlighted_code = TRUE  
)

xaringanExtra::use_xaringan_extra(c("tile_view", "animate_css", "tachyons", "panelset", "share_again", "search", "fit_screen", "editable", "clipboard"))

```


# Quick Refresher from Last Class

`r emo::ji("check")` Explain how ARIMA models work when compared to ARMA models.   

`r emo::ji("check")` Fit an ARIMA model to a time series, evaluate the residuals of a fitted ARMA model to assess goodness of fit, use the Ljung-Box test for correlation among the residuals of an ARIMA model.       

`r emo::ji("check")` Describe AIC, AICc, and BIC and how they are used to measure model fit.        

`r emo::ji("check")` Describe the algorithm used within the `auto.arima()` function to fit an ARIMA model.   

`r emo::ji("check")` Describe the results of the `auto.arima()` function.  


---

# Quick Refresher from the Lab

We will copy the code below and go through it line by line in class. 

```{r lab03_solution, eval=FALSE}
macros = tidyquant::tq_get(
  x = c('GNP', 'TOTALSA'),
  get = 'economic.data',
  from = '1947-01-01'
)

# to nest a dataset by symbol we need to first group the data
macros_nested = macros |> dplyr::group_by(symbol) |> tidyr::nest()

macros_nested_rolled = 
  macros_nested |> 
  # automatically obtaining the initial length of each training set and then rolling it
  dplyr::mutate(
    initial_length = (purrr::map_dbl(.x = data, .f = nrow) * 0.95) |>  ceiling(),    
    rolled = purrr::map2(
      .x = data, .y = initial_length,  .f = rsample::rolling_origin,  
      assess = 1, cumulative = TRUE
      ) ) |> # unnest rolled so that the length equals splits * symbols
  tidyr::unnest(rolled)

macros_nested_rolled = 
  macros_nested_rolled |> 
  dplyr::mutate(
    data = purrr::map(.x = splits, .f = rsample::analysis),
    
    # getting the training data
    train_dates = purrr::map(.x = data, .f = `[[`, 'date' ), # `[[` same as magrittr::extract2
    train_price = purrr::map(.x = data, .f = magrittr::extract2, 'price'),
    
    # testing data
    target_data = purrr::map(.x = splits, .f = rsample::assessment),
    target_date = purrr::map_dbl(.x = target_data, .f = magrittr::extract2, 'date') |>  lubridate::as_date(),
    target_price = purrr::map_dbl(.x = target_data, .f = magrittr::extract2, 'price')
  )

macros_df = macros_nested_rolled |>  
  dplyr::select(-c(data, train_dates, target_data))

macros_df = 
  macros_df |> 
  dplyr::mutate(
    naive_fct = purrr::map(.x = train_price, .f = forecast::naive, h = 1) |> 
      purrr::map_dbl(.f = magrittr::extract2, 'mean'),
    
    holt_fct = purrr::map(.x = train_price, .f = forecast::holt, h = 1) |> 
      purrr::map_dbl(.f = magrittr::extract2, 'mean'),
    
    auto_arima_fct = purrr::map(.x = train_price, .f = forecast::auto.arima) |>  
      purrr::map(.f = forecast::forecast, h = 1) |> purrr::map_dbl(.f = magrittr::extract2, 'mean')
  )

macros_results = 
  macros_df |> 
  dplyr::select(symbol, target_price:auto_arima_fct) |> 
  # this longer pivot will facilitate the computation of the metrics after grouping by method and symbol
  tidyr::pivot_longer(
    cols = dplyr::ends_with('_fct'),
    names_to = 'method',
    values_to = 'forecast'
  ) |> 
  dplyr::ungroup() |>
  dplyr::group_by( symbol, method ) |>
  dplyr::summarise(
    me = forecast::accuracy(object = forecast, x = target_price) |> magrittr::extract2(1),
    rmse = forecast::accuracy(object = forecast, x = target_price) |> magrittr::extract2(2),
    mae = forecast::accuracy(object = forecast, x = target_price) |> magrittr::extract2(3),
    mpe = forecast::accuracy(object = forecast, x = target_price) |> magrittr::extract2(4),
    mape = forecast::accuracy(object = forecast, x = target_price) |> magrittr::extract2(5)
  )
```



---



# Overview of Univariate Forecasting Methods

```{r read_ts_taxonomy, echo=FALSE, out.width='100%', fig.alt="A 10,000 foot view of univariate forecasting techniques", fig.align='center', fig.cap='A 10,000 foot view of forecasting techniques'}
knitr::include_graphics("../../figures/forecasting_methods1.png")
```

.footnote[
<html>
<hr>
</html>

**Notes:** My (incomplete) classification of **univariate** forecasting techniques, i.e., they exclude popular approaches used in multivariate time series forecasting.  
]

---


# Learning Objectives for Today's Class

- Recognize when to fit a seasonal ARIMA model.    

- Describe a seasonal ARIMA model and explain how it applies to a seasonal time series.    

---
class: inverse, center, middle

# Seasonal ARIMA Models


---

# When to Fit a Seasonal ARIMA?

.pull-left[

**Step 1:** Plot the Time Series 

For example, 

.font80[
```{r birth_read, eval=FALSE}
if(require(astsa)==F) install.packages('astsa')

# today's data: monthly us birth (Jan 48 - Jan 79)
us_birth = astsa::birth

forecast::autoplot(us_birth) + ggplot2::theme_bw()
```
]
]


.pull-right[
```{r birth_read_out, ref.label='birth_read', echo=FALSE, out.width='100%'}

```
]



---
count: false

# When to Fit a Seasonal ARIMA?

.pull-left[

**Step 2:** Difference if Needed 

For example, 

.font80[
```{r birth_diff, eval=FALSE}
# check for stationary ts
forecast::ndiffs(us_birth) 

# diff (if needed)
# using base diff since the input is a time series
# set differences to the differences needed
diff_birth = diff(us_birth, differences = 1)

forecast::autoplot(diff_birth) + 
  ggplot2::theme_bw()
```
]
]


.pull-right[
```{r birth_diff_out, ref.label='birth_diff', echo=FALSE, out.width='100%'}

```
]


---
count: false

# When to Fit a Seasonal ARIMA?

.pull-left[

**Step 3:** ACF and PACF on (differenced) ts

For example, 

.font80[
```{r birth_acf, eval=FALSE}
acf(diff_birth, plot = F, lag.max = 60) |> 
  forecast::autoplot() + ggplot2::theme_bw() +
  # specifying the number of labels for x-axis 
  ggplot2::scale_x_continuous(
    breaks = scales::pretty_breaks(6)
    )

pacf(diff_birth, plot = F,  lag.max = 60) |> 
  forecast::autoplot() + ggplot2::theme_bw() + 
  # specifying the number of labels for x-axis 
  ggplot2::scale_x_continuous(
    breaks = scales::pretty_breaks(6)
    )
```
]
]


.pull-right[
```{r birth_acf_out, ref.label='birth_acf', echo=FALSE, out.width='90%'}

```
]



---

# How to Fit a Seasonal ARIMA?

Let us continue with the `birth` dataset from the astsa package for a live coding example.

```{r birth_example, include=FALSE}
us_birth = birth

# Assessing stationarity and seasonality
# We will plot the data (given that it is already a ts, autoplot)
forecast::autoplot(us_birth) + ggplot2::theme_bw()


# Let us see what happens when we fit an auto.arima() model
### if you are fitting an auto.arima model for a series that you think is seasonal
### make sure that the input is a time-series with the appropriate freq
auto_model = forecast::auto.arima(us_birth)
summary(auto_model)
forecast::checkresiduals(auto_model)


# Ignoring what we have learned from the auto_model
# Ignoring that you noticed that the data is seasonal
# Starting intentionally with a bad model

forecast::ndiffs(us_birth)
diff_birth = diff(us_birth, differences = 1)

forecast::autoplot(diff_birth)
acf(diff_birth, plot = T, lag.max = 60)
pacf(diff_birth, plot = T, lag.max = 60)

# from the acf (ignoring seasonality), we would have said that we have a random walk
# from the pacf, we can potentially say that we cut off at lag 3

nonseasonal = forecast::Arima(us_birth, order = c(p = 3, d = 1, q = 0) )
summary(nonseasonal)
forecast::checkresiduals(nonseasonal)

acf(nonseasonal$residuals, lag.max = 60)
pacf(nonseasonal$residuals, lag.max = 60)

# a guess model
seasonal_hand_model = forecast::Arima(us_birth, order = c(p = 3, d = 1, q = 0),
                          seasonal = c(2, 1, 0) )
summary(seasonal_hand_model)
forecast::checkresiduals(seasonal_hand_model)

# This is a reasonable model as well
# Is it better than the auto ARIMA?

summary(seasonal_hand_model)
summary(auto_model)
# From the goodness of fit measures, the automodel has lower AICc and BIC
# which means that it is a slightly better model
```


---

# In-Class Activity

Use the data “netflix_growth_pct_2000.csv”.   
  - Fit an ARIMA model using the `forecast::auto.arima()` function.   
  - Describe the model that is fit.  
  - Evaluate the model residuals.  


---
class: inverse, center, middle

# Recap

---

# Summary of Main Points

By now, you should be able to do the following:   

- Recognize when to fit a seasonal ARIMA model.    

- Describe a seasonal ARIMA model and explain how it applies to a seasonal time series.  


---

# Things to Do to Prepare for Next Class

- Go through the slides, examples and make sure you have a good understanding of what we have covered.  

- Read Chapters $9.9$ in [Forecasting: Principles and Practice](https://otexts.com/fpp3/seasonal-arima.html).  
